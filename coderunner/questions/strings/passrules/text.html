<p>Usando il linguaggio assemblativo del RISC-V, scrivere una funzione \(passrules\) che riceva:</p>

<ul>
    <li>sul registro \(a0\), <b>l'indirizzo</b> in memoria di una stringa (array di byte)</li>
</ul>

<br/>
La funzione ritorna \(1\) se la stringa ricevuta contiene almeno 1 carattere maiuscolo ed almeno 1 carattere cifra. 
La funzione ritorna \(0\) in caso contrario.

<br/><br/>Il seguente codice in \(C\) realizza \(passrules\) (convertilo in RISC-V):

<pre>
int passrules(char str[]) {
    int uppercase = contains(str, 'A', 'Z');
    int numbers   = contains(str, '0', '9');
    return (uppercase && numbers);
}

// Tabella ASCII:
// ASCII 'A' -- hex: 0x41 dec: 65
// ASCII 'Z' -- hex: 0x5a dec: 90
// ASCII '0' -- hex: 0x30 dec: 48
// ASCII '9' -- hex: 0x39 dec: 57
</pre>

Il valore di ritorno deve essere lasciato sul registro \(a0\).

<br/><br/>
<b>\(passrules\) deve utilizzare \(contains\) sviluppata nell'esercizio precedente.</b>

<br><b>Attenzione:</b>
<ul>
    <li>NON INCOLLARE IL CODICE DI \(contains\) NELLA RISPOSTA</li>
    <li>Incollare nel campo di sotto soltanto il contenuto della funzione \(passrules\) (in RISC-V)</li>
    <li>Attenzione alle convenzioni di chiamata!</li>
    <li>Usare il seguente codice “main” per sviluppo e debugging nel simulatore RARS</li>
</ul>

<pre>
.globl _start
.data
      buffer: .string  "BADPass4"
.text
_start:
    # call passrules
    la   a0, buffer
    jal  ra, passrules

    #exit
    li   a7, 10
    ecall

#****************************************************
# completare la funzione passrules nel campo di sotto
</pre>

