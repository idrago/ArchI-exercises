<?xml version="1.0" encoding="UTF-8"?>
<quiz>
  <question type="coderunner">
    <name>
      <text>binsearch</text>
    </name>
    <questiontext format="html">
      <text><![CDATA[
<p>La ricerca dicotomica è un efficiente algoritmo che trova un dato elemento in un array ordinato. Ad ogni iterazione l'algoritmo confronta l'elemento in input con l'elemento che si trova nella posizione centrale della parte dell'array da visitare. Se tale elemento è uguale all'elemento di input l'algoritmo termina con successo. Se tale elemento è minore dell'elemento di input si continua la ricerca considerando solo la prima metà dell'array, in caso contrario si considera la seconda metà dell'array. L'algoritmo termina quando si è trovato l'elemento che si sta cercando oppure non è possibile continuare perché si è certi che l'elemento non si trova nell'array.
</p>

<p>
Si implementi la ricerca dicotomica in RISC-V. Di seguito trovate la funzione in C che implementa tale algoritmo.
</p>

<pre>
int binsearch(int array[], int size, int needle) {
    int low = 0;
    int high = size - 1;

    while (low <= high) {
        int mid = (low + high) / 2;

        if (array[mid] == needle) {
            return mid;
        } else if (array[mid] < needle) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    // needle not found
    return -1;
}
</pre>

<br><b>Attenzione:</b>
<ul>
    <li>Incollare nel campo di sotto soltanto il contenuto della funzione \(binsearch\) (in RISC-V)</li>
    <li>Attenzione alle convenzioni di chiamata!</li>
    <li>Usare il seguente codice "main" per sviluppo e debugging nel simulatore RARS</li>
</ul>

<pre>
.globl _start
.data
    needle: .word 2
    size:   .word 8
    array:  .word 1,2,3,7,9,10,11,15
.text
_start:
    # chiama binsearch
    la   a0, array
    la   a1, size
    lw   a1, 0(a1)
    la   a2, needle
    lw   a2, 0(a2)
    jal  ra, binsearch
    
    #exit
    li   a7, 10
    ecall

#***************************************************
# completare la funzione binsearch nel campo di sotto
</pre>
]]>
    </text>
    </questiontext>
    <defaultgrade>1</defaultgrade>
    <penalty>0</penalty>
    <hidden>0</hidden>
    <coderunnertype>riscv</coderunnertype>
    <prototypetype>0</prototypetype>
    <allornothing>1</allornothing>
    <penaltyregime>0</penaltyregime>
    <precheck>0</precheck>
    <hidecheck>0</hidecheck>
    <showsource>0</showsource>
    <answerboxlines>18</answerboxlines>
    <answerboxcolumns>100</answerboxcolumns>
    <answerpreload>binsearch:</answerpreload>
    <globalextra><![CDATA[
#*******************************************************************************
# main()
#*******************************************************************************
_start:    
    # puts numbers on the saved registers
    start_saved_registers_leaf

    # chiama binsearch
    la   a0, array
    la   a1, size
    lw   a1, 0(a1)
    la   a2, needle
    lw   a2, 0(a2)
    jal  ra, binsearch
    printreg a0, __ra0

    # check whether the saved registers are preserved
    check_saved_registers


]]>
    </globalextra>
    <useace></useace>
    <resultcolumns></resultcolumns>
    <template></template>
    <iscombinatortemplate></iscombinatortemplate>
    <allowmultiplestdins></allowmultiplestdins>
    <answer><![CDATA[
################################################################################
# Procedure binsearch(v, n, x)
# a0 -> v address
# a1 -> v size
# a2 -> x
################################################################################
binsearch:
    addi    t1, zero, 0  # left = 0
    addi    t2, a1, -1   # right = size - 1
    add     t3, zero, -1 # return value
    
binsearch_loop: # while loop
    bgt     t1, t2, binsearch_exit   # left > right, break
    add     t0, t1, t2   # mid = left + right
    srai    t0, t0, 1    # mid = (left + right) / 2

    # Get the element at the midpoint
    slli    t4, t0, 2    # Scale the midpoint by 4
    add     t4, a0, t4   # Get the memory address of arr[mid]
    lw      t4, 0(t4)    # Dereference arr[mid]

    # See if the needle (a2) > arr[mid]
    ble     a2, t4, binsearch_left
    # If we get here, then the needle is > arr[mid]
    addi    t1, t0, 1    # left = mid + 1
    j       binsearch_loop
binsearch_left:
    bge     a2, t4, binsearch_found
    # If we get here, then needle < arr[mid]
    addi    t2, t0, -1   # right = mid - 1
    j       binsearch_loop
binsearch_found:
    # If we get here, then needle == arr[mid]
    addi    t3, t0, 0

binsearch_exit:
    addi    a0, t3, 0
    ret


]]>
    </answer>
    <validateonsave>1</validateonsave>
    <testsplitterre></testsplitterre>
    <language></language>
    <acelang></acelang>
    <sandbox></sandbox>
    <grader></grader>
    <cputimelimitsecs></cputimelimitsecs>
    <memlimitmb></memlimitmb>
    <sandboxparams></sandboxparams>
    <templateparams></templateparams>
    <hoisttemplateparams>1</hoisttemplateparams>
    <templateparamslang>None</templateparamslang>
    <templateparamsevalpertry>0</templateparamsevalpertry>
    <templateparamsevald>{}</templateparamsevald>
    <twigall>0</twigall>
    <uiplugin></uiplugin>
    <uiparameters></uiparameters>
    <attachments>0</attachments>
    <attachmentsrequired>0</attachmentsrequired>
    <maxfilesize>10240</maxfilesize>
    <filenamesregex></filenamesregex>
    <filenamesexplain></filenamesexplain>
    <displayfeedback>0</displayfeedback>
    <giveupallowed>0</giveupallowed>
    <prototypeextra></prototypeextra>
    <testcases>

<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 1
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 0</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 1
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 5
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 1</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 5
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 23
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 7</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 23
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 0
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: -1</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 0
    size:   .word 8
    array:  .word 1,5,7,9,11,17,19,23

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 1
    size:   .word 1
    array:  .word 1

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 0</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 1
    size:   .word 1
    array:  .word 1

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 0
    size:   .word 1
    array:  .word 1

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: -1</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 0
    size:   .word 1
    array:  .word 1

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 5
    size:   .word 4
    array:  .word 1,5,7,9

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 1</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 5
    size:   .word 4
    array:  .word 1,5,7,9

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
<testcase testtype="0" useasexample="0" hiderestiffail="0" mark="1.00">
    <testcode>
        <text><![CDATA[
.section .data
    needle: .word 9
    size:   .word 4
    array:  .word 1,5,7,9

        ]]>
        </text>
    </testcode>
    <stdin>
        <text></text>
    </stdin>
    <expected>
        <text>a0: 3</text>
    </expected>
    <extra>
        <text><![CDATA[
.section .data
    needle: .word 9
    size:   .word 4
    array:  .word 1,5,7,9

        ]]></text>
    </extra>
    <display>
        <text>SHOW</text>
    </display>
</testcase>
    </testcases>
  </question>
</quiz>
